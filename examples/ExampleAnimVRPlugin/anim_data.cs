// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace AnimVRData
{

    using global::System;
    using global::FlatBuffers;

    public enum BrushType : short
    {
        Sphere = 0,
        Cube = 1,
        Splat = 2,
        Point = 3,
        Ribbon = 4,
    };

    public enum BrushMode : short
    {
        Paint = 0,
        Line = 1,
    };

    public struct Color : IFlatbufferObject
    {
        private Struct __p;
        public ByteBuffer ByteBuffer { get { return __p.bb; } }
        public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }
        public Color __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

        public float R { get { return __p.bb.GetFloat(__p.bb_pos + 0); } }
        public float G { get { return __p.bb.GetFloat(__p.bb_pos + 4); } }
        public float B { get { return __p.bb.GetFloat(__p.bb_pos + 8); } }
        public float A { get { return __p.bb.GetFloat(__p.bb_pos + 12); } }

        public static Offset<Color> CreateColor(FlatBufferBuilder builder, float R, float G, float B, float A)
        {
            builder.Prep(4, 16);
            builder.PutFloat(A);
            builder.PutFloat(B);
            builder.PutFloat(G);
            builder.PutFloat(R);
            return new Offset<Color>(builder.Offset);
        }
    };

    public struct Vec3 : IFlatbufferObject
    {
        private Struct __p;
        public ByteBuffer ByteBuffer { get { return __p.bb; } }
        public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }
        public Vec3 __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

        public float X { get { return __p.bb.GetFloat(__p.bb_pos + 0); } }
        public float Y { get { return __p.bb.GetFloat(__p.bb_pos + 4); } }
        public float Z { get { return __p.bb.GetFloat(__p.bb_pos + 8); } }

        public static Offset<Vec3> CreateVec3(FlatBufferBuilder builder, float X, float Y, float Z)
        {
            builder.Prep(4, 12);
            builder.PutFloat(Z);
            builder.PutFloat(Y);
            builder.PutFloat(X);
            return new Offset<Vec3>(builder.Offset);
        }
    };

    public struct Vec2 : IFlatbufferObject
    {
        private Struct __p;
        public ByteBuffer ByteBuffer { get { return __p.bb; } }
        public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }
        public Vec2 __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

        public float X { get { return __p.bb.GetFloat(__p.bb_pos + 0); } }
        public float Y { get { return __p.bb.GetFloat(__p.bb_pos + 4); } }

        public static Offset<Vec2> CreateVec2(FlatBufferBuilder builder, float X, float Y)
        {
            builder.Prep(4, 8);
            builder.PutFloat(Y);
            builder.PutFloat(X);
            return new Offset<Vec2>(builder.Offset);
        }
    };

    public struct Quaternion : IFlatbufferObject
    {
        private Struct __p;
        public ByteBuffer ByteBuffer { get { return __p.bb; } }
        public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }
        public Quaternion __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

        public float X { get { return __p.bb.GetFloat(__p.bb_pos + 0); } }
        public float Y { get { return __p.bb.GetFloat(__p.bb_pos + 4); } }
        public float Z { get { return __p.bb.GetFloat(__p.bb_pos + 8); } }
        public float W { get { return __p.bb.GetFloat(__p.bb_pos + 12); } }

        public static Offset<Quaternion> CreateQuaternion(FlatBufferBuilder builder, float X, float Y, float Z, float W)
        {
            builder.Prep(4, 16);
            builder.PutFloat(W);
            builder.PutFloat(Z);
            builder.PutFloat(Y);
            builder.PutFloat(X);
            return new Offset<Quaternion>(builder.Offset);
        }
    };

    public struct Transform : IFlatbufferObject
    {
        private Struct __p;
        public ByteBuffer ByteBuffer { get { return __p.bb; } }
        public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }
        public Transform __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

        public Vec3 Pos { get { return (new Vec3()).__assign(__p.bb_pos + 0, __p.bb); } }
        public Quaternion Rot { get { return (new Quaternion()).__assign(__p.bb_pos + 12, __p.bb); } }
        public Vec3 Scale { get { return (new Vec3()).__assign(__p.bb_pos + 28, __p.bb); } }

        public static Offset<Transform> CreateTransform(FlatBufferBuilder builder, float pos_X, float pos_Y, float pos_Z, float rot_X, float rot_Y, float rot_Z, float rot_W, float scale_X, float scale_Y, float scale_Z)
        {
            builder.Prep(4, 40);
            builder.Prep(4, 12);
            builder.PutFloat(scale_Z);
            builder.PutFloat(scale_Y);
            builder.PutFloat(scale_X);
            builder.Prep(4, 16);
            builder.PutFloat(rot_W);
            builder.PutFloat(rot_Z);
            builder.PutFloat(rot_Y);
            builder.PutFloat(rot_X);
            builder.Prep(4, 12);
            builder.PutFloat(pos_Z);
            builder.PutFloat(pos_Y);
            builder.PutFloat(pos_X);
            return new Offset<Transform>(builder.Offset);
        }
    };

    public struct BrushSettings : IFlatbufferObject
    {
        private Struct __p;
        public ByteBuffer ByteBuffer { get { return __p.bb; } }
        public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }
        public BrushSettings __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

        public BrushType BrushType { get { return (BrushType)__p.bb.GetShort(__p.bb_pos + 0); } }
        public BrushMode BrushMode { get { return (BrushMode)__p.bb.GetShort(__p.bb_pos + 2); } }
        public bool IsOneSided { get { return 0 != __p.bb.Get(__p.bb_pos + 4); } }
        public bool IsFlat { get { return 0 != __p.bb.Get(__p.bb_pos + 5); } }
        public bool TaperOpacity { get { return 0 != __p.bb.Get(__p.bb_pos + 6); } }
        public bool TaperShape { get { return 0 != __p.bb.Get(__p.bb_pos + 7); } }
        public bool ConstantWidth { get { return 0 != __p.bb.Get(__p.bb_pos + 8); } }
        public bool MultiLine { get { return 0 != __p.bb.Get(__p.bb_pos + 9); } }
        public bool IsWeb { get { return 0 != __p.bb.Get(__p.bb_pos + 10); } }
        public bool IsObjectSpaceTex { get { return 0 != __p.bb.Get(__p.bb_pos + 11); } }
        public int TextureIndex { get { return __p.bb.GetInt(__p.bb_pos + 12); } }

        public static Offset<BrushSettings> CreateBrushSettings(FlatBufferBuilder builder, BrushType BrushType, BrushMode BrushMode, bool IsOneSided, bool IsFlat, bool TaperOpacity, bool TaperShape, bool ConstantWidth, bool MultiLine, bool IsWeb, bool IsObjectSpaceTex, int TextureIndex)
        {
            builder.Prep(4, 16);
            builder.PutInt(TextureIndex);
            builder.PutBool(IsObjectSpaceTex);
            builder.PutBool(IsWeb);
            builder.PutBool(MultiLine);
            builder.PutBool(ConstantWidth);
            builder.PutBool(TaperShape);
            builder.PutBool(TaperOpacity);
            builder.PutBool(IsFlat);
            builder.PutBool(IsOneSided);
            builder.PutShort((short)BrushMode);
            builder.PutShort((short)BrushType);
            return new Offset<BrushSettings>(builder.Offset);
        }
    };

    public struct Line : IFlatbufferObject
    {
        private Table __p;
        public ByteBuffer ByteBuffer { get { return __p.bb; } }
        public static Line GetRootAsLine(ByteBuffer _bb) { return GetRootAsLine(_bb, new Line()); }
        public static Line GetRootAsLine(ByteBuffer _bb, Line obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
        public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }
        public Line __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

        public BrushSettings? Settings { get { int o = __p.__offset(4); return o != 0 ? (BrushSettings?)(new BrushSettings()).__assign(o + __p.bb_pos, __p.bb) : null; } }
        public Transform? Trans { get { int o = __p.__offset(6); return o != 0 ? (Transform?)(new Transform()).__assign(o + __p.bb_pos, __p.bb) : null; } }
        public Vec3? Points(int j) { int o = __p.__offset(8); return o != 0 ? (Vec3?)(new Vec3()).__assign(__p.__vector(o) + j * 12, __p.bb) : null; }
        public int PointsLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }
        public float Widths(int j) { int o = __p.__offset(10); return o != 0 ? __p.bb.GetFloat(__p.__vector(o) + j * 4) : (float)0; }
        public int WidthsLength { get { int o = __p.__offset(10); return o != 0 ? __p.__vector_len(o) : 0; } }
        public ArraySegment<byte>? GetWidthsBytes() { return __p.__vector_as_arraysegment(10); }
        public Color? Colors(int j) { int o = __p.__offset(12); return o != 0 ? (Color?)(new Color()).__assign(__p.__vector(o) + j * 16, __p.bb) : null; }
        public int ColorsLength { get { int o = __p.__offset(12); return o != 0 ? __p.__vector_len(o) : 0; } }
        public float Lights(int j) { int o = __p.__offset(14); return o != 0 ? __p.bb.GetFloat(__p.__vector(o) + j * 4) : (float)0; }
        public int LightsLength { get { int o = __p.__offset(14); return o != 0 ? __p.__vector_len(o) : 0; } }
        public ArraySegment<byte>? GetLightsBytes() { return __p.__vector_as_arraysegment(14); }
        public Quaternion? Rotations(int j) { int o = __p.__offset(16); return o != 0 ? (Quaternion?)(new Quaternion()).__assign(__p.__vector(o) + j * 16, __p.bb) : null; }
        public int RotationsLength { get { int o = __p.__offset(16); return o != 0 ? __p.__vector_len(o) : 0; } }
        public Quaternion? CamOrientations(int j) { int o = __p.__offset(18); return o != 0 ? (Quaternion?)(new Quaternion()).__assign(__p.__vector(o) + j * 16, __p.bb) : null; }
        public int CamOrientationsLength { get { int o = __p.__offset(18); return o != 0 ? __p.__vector_len(o) : 0; } }

        public static void StartLine(FlatBufferBuilder builder) { builder.StartObject(8); }
        public static void AddSettings(FlatBufferBuilder builder, Offset<BrushSettings> settingsOffset) { builder.AddStruct(0, settingsOffset.Value, 0); }
        public static void AddTrans(FlatBufferBuilder builder, Offset<Transform> transOffset) { builder.AddStruct(1, transOffset.Value, 0); }
        public static void AddPoints(FlatBufferBuilder builder, VectorOffset pointsOffset) { builder.AddOffset(2, pointsOffset.Value, 0); }
        public static void StartPointsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(12, numElems, 4); }
        public static void AddWidths(FlatBufferBuilder builder, VectorOffset widthsOffset) { builder.AddOffset(3, widthsOffset.Value, 0); }
        public static VectorOffset CreateWidthsVector(FlatBufferBuilder builder, float[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddFloat(data[i]); return builder.EndVector(); }
        public static void StartWidthsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
        public static void AddColors(FlatBufferBuilder builder, VectorOffset colorsOffset) { builder.AddOffset(4, colorsOffset.Value, 0); }
        public static void StartColorsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(16, numElems, 4); }
        public static void AddLights(FlatBufferBuilder builder, VectorOffset lightsOffset) { builder.AddOffset(5, lightsOffset.Value, 0); }
        public static VectorOffset CreateLightsVector(FlatBufferBuilder builder, float[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddFloat(data[i]); return builder.EndVector(); }
        public static void StartLightsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
        public static void AddRotations(FlatBufferBuilder builder, VectorOffset rotationsOffset) { builder.AddOffset(6, rotationsOffset.Value, 0); }
        public static void StartRotationsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(16, numElems, 4); }
        public static void AddCamOrientations(FlatBufferBuilder builder, VectorOffset camOrientationsOffset) { builder.AddOffset(7, camOrientationsOffset.Value, 0); }
        public static void StartCamOrientationsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(16, numElems, 4); }
        public static Offset<Line> EndLine(FlatBufferBuilder builder)
        {
            int o = builder.EndObject();
            return new Offset<Line>(o);
        }
    };

    public struct Frame : IFlatbufferObject
    {
        private Table __p;
        public ByteBuffer ByteBuffer { get { return __p.bb; } }
        public static Frame GetRootAsFrame(ByteBuffer _bb) { return GetRootAsFrame(_bb, new Frame()); }
        public static Frame GetRootAsFrame(ByteBuffer _bb, Frame obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
        public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }
        public Frame __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

        public Transform? Trans { get { int o = __p.__offset(4); return o != 0 ? (Transform?)(new Transform()).__assign(o + __p.bb_pos, __p.bb) : null; } }
        public bool IsInstance { get { int o = __p.__offset(6); return o != 0 ? 0 != __p.bb.Get(o + __p.bb_pos) : (bool)false; } }
        public Line? Lines(int j) { int o = __p.__offset(8); return o != 0 ? (Line?)(new Line()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
        public int LinesLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }

        public static void StartFrame(FlatBufferBuilder builder) { builder.StartObject(3); }
        public static void AddTrans(FlatBufferBuilder builder, Offset<Transform> transOffset) { builder.AddStruct(0, transOffset.Value, 0); }
        public static void AddIsInstance(FlatBufferBuilder builder, bool isInstance) { builder.AddBool(1, isInstance, false); }
        public static void AddLines(FlatBufferBuilder builder, VectorOffset linesOffset) { builder.AddOffset(2, linesOffset.Value, 0); }
        public static VectorOffset CreateLinesVector(FlatBufferBuilder builder, Offset<Line>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
        public static void StartLinesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
        public static Offset<Frame> EndFrame(FlatBufferBuilder builder)
        {
            int o = builder.EndObject();
            return new Offset<Frame>(o);
        }
    };

    public struct Playable : IFlatbufferObject
    {
        private Table __p;
        public ByteBuffer ByteBuffer { get { return __p.bb; } }
        public static Playable GetRootAsPlayable(ByteBuffer _bb) { return GetRootAsPlayable(_bb, new Playable()); }
        public static Playable GetRootAsPlayable(ByteBuffer _bb, Playable obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
        public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }
        public Playable __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

        public Transform? Trans { get { int o = __p.__offset(4); return o != 0 ? (Transform?)(new Transform()).__assign(o + __p.bb_pos, __p.bb) : null; } }
        public bool IsVisible { get { int o = __p.__offset(6); return o != 0 ? 0 != __p.bb.Get(o + __p.bb_pos) : (bool)false; } }
        public float Opacity { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
        public int IndexInSymbol { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
        public string DisplayName { get { int o = __p.__offset(12); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
        public ArraySegment<byte>? GetDisplayNameBytes() { return __p.__vector_as_arraysegment(12); }
        public bool ExpandedInLayerList { get { int o = __p.__offset(14); return o != 0 ? 0 != __p.bb.Get(o + __p.bb_pos) : (bool)false; } }

        public static void StartPlayable(FlatBufferBuilder builder) { builder.StartObject(6); }
        public static void AddTrans(FlatBufferBuilder builder, Offset<Transform> transOffset) { builder.AddStruct(0, transOffset.Value, 0); }
        public static void AddIsVisible(FlatBufferBuilder builder, bool isVisible) { builder.AddBool(1, isVisible, false); }
        public static void AddOpacity(FlatBufferBuilder builder, float opacity) { builder.AddFloat(2, opacity, 0.0f); }
        public static void AddIndexInSymbol(FlatBufferBuilder builder, int indexInSymbol) { builder.AddInt(3, indexInSymbol, 0); }
        public static void AddDisplayName(FlatBufferBuilder builder, StringOffset displayNameOffset) { builder.AddOffset(4, displayNameOffset.Value, 0); }
        public static void AddExpandedInLayerList(FlatBufferBuilder builder, bool expandedInLayerList) { builder.AddBool(5, expandedInLayerList, false); }
        public static Offset<Playable> EndPlayable(FlatBufferBuilder builder)
        {
            int o = builder.EndObject();
            return new Offset<Playable>(o);
        }
    };

    public struct Timeline : IFlatbufferObject
    {
        private Table __p;
        public ByteBuffer ByteBuffer { get { return __p.bb; } }
        public static Timeline GetRootAsTimeline(ByteBuffer _bb) { return GetRootAsTimeline(_bb, new Timeline()); }
        public static Timeline GetRootAsTimeline(ByteBuffer _bb, Timeline obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
        public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }
        public Timeline __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

        public Playable? Base { get { int o = __p.__offset(4); return o != 0 ? (Playable?)(new Playable()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
        public Frame? Frames(int j) { int o = __p.__offset(6); return o != 0 ? (Frame?)(new Frame()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
        public int FramesLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }

        public static Offset<Timeline> CreateTimeline(FlatBufferBuilder builder,
            Offset<Playable> baseOffset = default(Offset<Playable>),
            VectorOffset framesOffset = default(VectorOffset))
        {
            builder.StartObject(2);
            Timeline.AddFrames(builder, framesOffset);
            Timeline.AddBase(builder, baseOffset);
            return Timeline.EndTimeline(builder);
        }

        public static void StartTimeline(FlatBufferBuilder builder) { builder.StartObject(2); }
        public static void AddBase(FlatBufferBuilder builder, Offset<Playable> baseOffset) { builder.AddOffset(0, baseOffset.Value, 0); }
        public static void AddFrames(FlatBufferBuilder builder, VectorOffset framesOffset) { builder.AddOffset(1, framesOffset.Value, 0); }
        public static VectorOffset CreateFramesVector(FlatBufferBuilder builder, Offset<Frame>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
        public static void StartFramesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
        public static Offset<Timeline> EndTimeline(FlatBufferBuilder builder)
        {
            int o = builder.EndObject();
            return new Offset<Timeline>(o);
        }
    };

    public struct Symbol : IFlatbufferObject
    {
        private Table __p;
        public ByteBuffer ByteBuffer { get { return __p.bb; } }
        public static Symbol GetRootAsSymbol(ByteBuffer _bb) { return GetRootAsSymbol(_bb, new Symbol()); }
        public static Symbol GetRootAsSymbol(ByteBuffer _bb, Symbol obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
        public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }
        public Symbol __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

        public Playable? Base { get { int o = __p.__offset(4); return o != 0 ? (Playable?)(new Playable()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
        public Timeline? Timelines(int j) { int o = __p.__offset(6); return o != 0 ? (Timeline?)(new Timeline()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
        public int TimelinesLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }
        public Symbol? Symbols(int j) { int o = __p.__offset(8); return o != 0 ? (Symbol?)(new Symbol()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
        public int SymbolsLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }

        public static Offset<Symbol> CreateSymbol(FlatBufferBuilder builder,
            Offset<Playable> baseOffset = default(Offset<Playable>),
            VectorOffset timelinesOffset = default(VectorOffset),
            VectorOffset symbolsOffset = default(VectorOffset))
        {
            builder.StartObject(3);
            Symbol.AddSymbols(builder, symbolsOffset);
            Symbol.AddTimelines(builder, timelinesOffset);
            Symbol.AddBase(builder, baseOffset);
            return Symbol.EndSymbol(builder);
        }

        public static void StartSymbol(FlatBufferBuilder builder) { builder.StartObject(3); }
        public static void AddBase(FlatBufferBuilder builder, Offset<Playable> baseOffset) { builder.AddOffset(0, baseOffset.Value, 0); }
        public static void AddTimelines(FlatBufferBuilder builder, VectorOffset timelinesOffset) { builder.AddOffset(1, timelinesOffset.Value, 0); }
        public static VectorOffset CreateTimelinesVector(FlatBufferBuilder builder, Offset<Timeline>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
        public static void StartTimelinesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
        public static void AddSymbols(FlatBufferBuilder builder, VectorOffset symbolsOffset) { builder.AddOffset(2, symbolsOffset.Value, 0); }
        public static VectorOffset CreateSymbolsVector(FlatBufferBuilder builder, Offset<Symbol>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
        public static void StartSymbolsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
        public static Offset<Symbol> EndSymbol(FlatBufferBuilder builder)
        {
            int o = builder.EndObject();
            return new Offset<Symbol>(o);
        }
    };

    public struct Stage : IFlatbufferObject
    {
        private Table __p;
        public ByteBuffer ByteBuffer { get { return __p.bb; } }
        public static Stage GetRootAsStage(ByteBuffer _bb) { return GetRootAsStage(_bb, new Stage()); }
        public static Stage GetRootAsStage(ByteBuffer _bb, Stage obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
        public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }
        public Stage __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

        public Transform? Trans { get { int o = __p.__offset(4); return o != 0 ? (Transform?)(new Transform()).__assign(o + __p.bb_pos, __p.bb) : null; } }
        public Symbol? Symbols(int j) { int o = __p.__offset(6); return o != 0 ? (Symbol?)(new Symbol()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
        public int SymbolsLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }

        public static void StartStage(FlatBufferBuilder builder) { builder.StartObject(2); }
        public static void AddTrans(FlatBufferBuilder builder, Offset<Transform> transOffset) { builder.AddStruct(0, transOffset.Value, 0); }
        public static void AddSymbols(FlatBufferBuilder builder, VectorOffset symbolsOffset) { builder.AddOffset(1, symbolsOffset.Value, 0); }
        public static VectorOffset CreateSymbolsVector(FlatBufferBuilder builder, Offset<Symbol>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
        public static void StartSymbolsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
        public static Offset<Stage> EndStage(FlatBufferBuilder builder)
        {
            int o = builder.EndObject();
            return new Offset<Stage>(o);
        }
        public static void FinishStageBuffer(FlatBufferBuilder builder, Offset<Stage> offset) { builder.Finish(offset.Value); }
    };


}
